{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction # PDM is a modern Python package manager with PEP 582 support. It installs and manages packages in a similar way to npm that doesn't need to create a virtualenv at all! Feature highlights # PEP 582 local package installer and runner, no virtualenv involved at all. Simple and relatively fast dependency resolver, mainly for large binary distributions. A PEP 517 build backend. Installation # PDM requires Python 3.7+ to be installed. It works on multiple platforms including Windows, Linux and MacOS. Note There is no restriction about what Python version that your project is using but installing PDM itself needs Python 3.7+. Recommended installation method # To avoid messing up with the system Python environemnt, the most recommended way to install PDM is via pipx : $ pipx install pdm Other installation methods # Install PDM into user site with pip : $ pip install --user pdm Use with IDE # Now there are not built-in support or plugins for PEP 582 in most IDEs, you have to configure your tools manually. PDM will write and store project-wide configurations in .pdm.toml and you are recommended to add following lines in the .gitignore : .pdm.toml __pypackages__ / PyCharm # Mark __pypackages__/<major.minor>/lib as Sources Root. VSCode # Add following in the settings.json : { ... \"python.autoComplete.extraPaths\" : [ \"__pypackages__/<major.minor>/lib\" ] }","title":"Introduction"},{"location":"#introduction","text":"PDM is a modern Python package manager with PEP 582 support. It installs and manages packages in a similar way to npm that doesn't need to create a virtualenv at all!","title":"Introduction"},{"location":"#feature-highlights","text":"PEP 582 local package installer and runner, no virtualenv involved at all. Simple and relatively fast dependency resolver, mainly for large binary distributions. A PEP 517 build backend.","title":"Feature highlights"},{"location":"#installation","text":"PDM requires Python 3.7+ to be installed. It works on multiple platforms including Windows, Linux and MacOS. Note There is no restriction about what Python version that your project is using but installing PDM itself needs Python 3.7+.","title":"Installation"},{"location":"#recommended-installation-method","text":"To avoid messing up with the system Python environemnt, the most recommended way to install PDM is via pipx : $ pipx install pdm","title":"Recommended installation method"},{"location":"#other-installation-methods","text":"Install PDM into user site with pip : $ pip install --user pdm","title":"Other installation methods"},{"location":"#use-with-ide","text":"Now there are not built-in support or plugins for PEP 582 in most IDEs, you have to configure your tools manually. PDM will write and store project-wide configurations in .pdm.toml and you are recommended to add following lines in the .gitignore : .pdm.toml __pypackages__ /","title":"Use with IDE"},{"location":"#pycharm","text":"Mark __pypackages__/<major.minor>/lib as Sources Root.","title":"PyCharm"},{"location":"#vscode","text":"Add following in the settings.json : { ... \"python.autoComplete.extraPaths\" : [ \"__pypackages__/<major.minor>/lib\" ] }","title":"VSCode"},{"location":"changelog/","text":"Change Log # Release v0.8.2 (2020-05-03) # Bug Fixes # Update resolvers to resolvelib 0.4.0. #118 Release v0.8.1 (2020-04-22) # Dependencies # Switch to upstream resolvelib 0.3.0 . #116 Release v0.8.0 (2020-04-20) # Features & Improvements # Add a new command to search for packages #111 Add show command to show package metadata. #114 Bug Fixes # Fix a bug that environment markers cannot be evaluated correctly if extra's are connected with \"or\". #107 Don't consult PyPI JSON API by default for package metadata. #112 Elimate backslashes in markers for TOML documents. #115 Release v0.7.1 (2020-04-13) # Bug Fixes # Editable packages requires setuptools to be installed in the isolated environment. Release v0.7.0 (2020-04-12) # Features & Improvements # Disable loading of site-packages under PEP 582 mode. #100 Bug Fixes # Fix a bug that TOML parsing error is not correctly captured. #101 Fix a bug of building wheels with C extensions that the platform in file name is incorrect. #99 Release v0.6.5 (2020-04-07) # Bug Fixes # Unix style executable script suffix is missing. Release v0.6.4 (2020-04-07) # Features & Improvements # Update shebang lines in the exetuable scripts when doing pdm use . #96 Auto detect commonly used venv directories. #97 Release v0.6.3 (2020-03-30) # Bug Fixes # Fix a bug of moving files across different file system. #95 Release v0.6.2 (2020-03-29) # Bug Fixes # Validate user input for python_requires when initializing project. #89 Ensure wheel package is available before building packages. #90 Fix an issue of remove command that will unexpectedly uninstall packages in default section. #92 Dependencies # Update dependencies pythonfinder , python-cfonts , pip-shims and many others. Drop dependency vistir . #89 Release v0.6.1 (2020-03-25) # Features & Improvements # Redirect output messages to log file for installation and locking. #84 Bug Fixes # Fix a bug that parallel installation fails due to setuptools reinstalling. #83 Release v0.6.0 (2020-03-20) # Features & Improvements # Support specifying build script for C extensions. #23 Add test cases for pdm build . #81 Make it configurable whether to consult PyPI JSON API since it may be not trustable. Support parallel installation. Add new command pmd import to import project metadata from Pipfile , poetry , flit , requirements.txt . #79 pdm init and pdm install will auto-detect possibile files that can be imported. Bug Fixes # Fix wheel builds when package_dir is mapped. #81 pdm init will use the current directory rather than finding the parents when global project is not activated. Release v0.5.0 (2020-03-14) # Features & Improvements # Introduce a super easy-to-extend plug-in system to PDM. #75 Improved Documentation # Documentation on how to write a plugin. #75 Bug Fixes # Fix a typo in metadata parsing from plugins to entry_points Release v0.4.2 (2020-03-13) # Features & Improvements # Refactor the CLI part, switch from click to argparse , for better extensibility. #73 Allow users to configure to install packages into venv when it is activated. #74 Release v0.4.1 (2020-03-11) # Features & Improvements # Add a minimal dependency set for global project. #72 Release v0.4.0 (2020-03-10) # Features & Improvements # Global project support Add a new option -g/--global to manage global project. The default location is at ~/.pdm/global-project . Use the virtualenv interpreter when detected inside an activated venv. Add a new option -p/--project to select project root other than the default one. #30 Add a new command pdm config del to delete an existing config item. #71 Bug Fixes # Fix a URL parsing issue that username will be dropped in the SSH URL. #68 Improved Documentation # Add docs for global project and selecting project path. #30 Release v0.3.2 (2020-03-08) # Features & Improvements # Display all available Python interpreters if users don't give one in pdm init . #67 Bug Fixes # Regard 4.0 as infinite upper bound when checking subsetting. #66 Release v0.3.1 (2020-03-07) # Bug Fixes # Fix a bug that ImpossiblePySpec 's hash clashes with normal one. Release v0.3.0 (2020-02-28) # Features & Improvements # Add a new command pdm config to inspect configurations. #26 Add a new command pdm cache clear to clean caches. #63 Bug Fixes # Correctly show dependency graph when circular dependencies exist. #62 Improved Documentation # Write the initial documentation for PDM. #14 Release v0.2.6 (2020-02-25) # Features & Improvements # Improve the user interface of selecting Python interpreter. #54 Bug Fixes # Fix the wheel installer to correctly unparse the flags of console scripts. #56 Fix a bug that OS-dependent hashes are not saved. #57 Release v0.2.5 (2020-02-22) # Features & Improvements # Allow specifying Python interpreter via --python option in pdm init . #49 Set python_requires when initializing and defaults to >={current_version} . #50 Bug Fixes # Always consider wheels before tarballs; correctly merge markers from different parents. #47 Filter out incompatible wheels when installing. #48 Release v0.2.4 (2020-02-21) # Bug Fixes # Use the project local interpreter to build wheels. #43 Correctly merge Python specifiers when possible. #4 Release v0.2.3 (2020-02-21) # Bug Fixes # Fix a bug that editable build generates a malformed setup.py . Release v0.2.2 (2020-02-20) # Features & Improvements # Add a fancy greeting banner when user types pdm --help . #42 Bug Fixes # Fix the RECORD file in built wheel. #41 Dependencies # Add dependency python-cfonts to display banner. #42 Release v0.2.1 (2020-02-18) # Bug Fixes # Fix a bug that short python_version markers can't be parsed correctly. #38 Make _editable_intall.py compatible with Py2. Release v0.2.0 (2020-02-14) # Features & Improvements # New option: pdm list --graph to show a dependency graph of the working set. #10 New option: pdm update --unconstrained to ignore the version constraint of given packages. #13 Improve the error message when project is not initialized before running comands. #19 Pinned candidates in lock file are reused when relocking during pdm install . #33 Use the pyenv interperter value if pyenv is installed. #36 Introduce a new command pdm info to show project environment information. #9 Bug Fixes # Fix a bug that candidate hashes will be lost when reused. #11 Dependencies # Update pip to 20.0 , update pip_shims to 0.5.0 . #28 Miscellany # Add a script named setup_dev.py for the convenience to setup pdm for development. #29 Release v0.1.2 (2020-02-09) # Features # New command pdm use to switch python versions. #8 New option pdm list --graph to show a dependency graph. #10 Read metadata from lockfile when pinned candidate is reused. Release v0.1.1 (2020-02-07) # Features # Get version from the specified file. #6 Add column header to pdm list output. Release v0.1.0 (2020-02-07) # Bugfixes # Pass exit code to parent process in pdm run. Fix error handling for CLI. #19 Miscellany # Refactor the installer mocking for tests. Release v0.0.5 (2020-01-22) # Improvements # Ensure pypi index url is fetched in addition to the source settings. #3 Bugfixes # Fix an issue that leading \"c\"s are mistakenly stripped. #5 Fix an error with PEP 517 building. Release v0.0.4 (2020-01-22) # Improvements # Fix editable installation, now editable scripts can also be executed from outside! Content hash is calculated based on dependencies and sources, not other metadata. Bugfixes # Fix an issue that editable distributions can not be removed. Release v0.0.3 (2020-01-22) # Features # Add pdm init to bootstrap a project. Release v0.0.2 (2020-01-22) # Features # A complete functioning PEP 517 build backend. pdm builld command. Miscellany # Add a Chinese REAME Features # Add pdm init to bootstrap a project. Release v0.0.1 (2020-01-20) # Features # A dependency resolver that just works. A PEP 582 installer. PEP 440 version specifiers. PEP 508 environment markers. Running scripts with PEP 582 local packages. Console scripts are injected with local paths. A neet CLI. add, lock, list, update, remove commands. PEP 517 build backends. Continuous Integration.","title":"Change Log"},{"location":"changelog/#change-log","text":"","title":"Change Log"},{"location":"changelog/#release-v082-2020-05-03","text":"","title":"Release v0.8.2 (2020-05-03)"},{"location":"changelog/#bug-fixes","text":"Update resolvers to resolvelib 0.4.0. #118","title":"Bug Fixes"},{"location":"changelog/#release-v081-2020-04-22","text":"","title":"Release v0.8.1 (2020-04-22)"},{"location":"changelog/#dependencies","text":"Switch to upstream resolvelib 0.3.0 . #116","title":"Dependencies"},{"location":"changelog/#release-v080-2020-04-20","text":"","title":"Release v0.8.0 (2020-04-20)"},{"location":"changelog/#features-improvements","text":"Add a new command to search for packages #111 Add show command to show package metadata. #114","title":"Features &amp; Improvements"},{"location":"changelog/#bug-fixes_1","text":"Fix a bug that environment markers cannot be evaluated correctly if extra's are connected with \"or\". #107 Don't consult PyPI JSON API by default for package metadata. #112 Elimate backslashes in markers for TOML documents. #115","title":"Bug Fixes"},{"location":"changelog/#release-v071-2020-04-13","text":"","title":"Release v0.7.1 (2020-04-13)"},{"location":"changelog/#bug-fixes_2","text":"Editable packages requires setuptools to be installed in the isolated environment.","title":"Bug Fixes"},{"location":"changelog/#release-v070-2020-04-12","text":"","title":"Release v0.7.0 (2020-04-12)"},{"location":"changelog/#features-improvements_1","text":"Disable loading of site-packages under PEP 582 mode. #100","title":"Features &amp; Improvements"},{"location":"changelog/#bug-fixes_3","text":"Fix a bug that TOML parsing error is not correctly captured. #101 Fix a bug of building wheels with C extensions that the platform in file name is incorrect. #99","title":"Bug Fixes"},{"location":"changelog/#release-v065-2020-04-07","text":"","title":"Release v0.6.5 (2020-04-07)"},{"location":"changelog/#bug-fixes_4","text":"Unix style executable script suffix is missing.","title":"Bug Fixes"},{"location":"changelog/#release-v064-2020-04-07","text":"","title":"Release v0.6.4 (2020-04-07)"},{"location":"changelog/#features-improvements_2","text":"Update shebang lines in the exetuable scripts when doing pdm use . #96 Auto detect commonly used venv directories. #97","title":"Features &amp; Improvements"},{"location":"changelog/#release-v063-2020-03-30","text":"","title":"Release v0.6.3 (2020-03-30)"},{"location":"changelog/#bug-fixes_5","text":"Fix a bug of moving files across different file system. #95","title":"Bug Fixes"},{"location":"changelog/#release-v062-2020-03-29","text":"","title":"Release v0.6.2 (2020-03-29)"},{"location":"changelog/#bug-fixes_6","text":"Validate user input for python_requires when initializing project. #89 Ensure wheel package is available before building packages. #90 Fix an issue of remove command that will unexpectedly uninstall packages in default section. #92","title":"Bug Fixes"},{"location":"changelog/#dependencies_1","text":"Update dependencies pythonfinder , python-cfonts , pip-shims and many others. Drop dependency vistir . #89","title":"Dependencies"},{"location":"changelog/#release-v061-2020-03-25","text":"","title":"Release v0.6.1 (2020-03-25)"},{"location":"changelog/#features-improvements_3","text":"Redirect output messages to log file for installation and locking. #84","title":"Features &amp; Improvements"},{"location":"changelog/#bug-fixes_7","text":"Fix a bug that parallel installation fails due to setuptools reinstalling. #83","title":"Bug Fixes"},{"location":"changelog/#release-v060-2020-03-20","text":"","title":"Release v0.6.0 (2020-03-20)"},{"location":"changelog/#features-improvements_4","text":"Support specifying build script for C extensions. #23 Add test cases for pdm build . #81 Make it configurable whether to consult PyPI JSON API since it may be not trustable. Support parallel installation. Add new command pmd import to import project metadata from Pipfile , poetry , flit , requirements.txt . #79 pdm init and pdm install will auto-detect possibile files that can be imported.","title":"Features &amp; Improvements"},{"location":"changelog/#bug-fixes_8","text":"Fix wheel builds when package_dir is mapped. #81 pdm init will use the current directory rather than finding the parents when global project is not activated.","title":"Bug Fixes"},{"location":"changelog/#release-v050-2020-03-14","text":"","title":"Release v0.5.0 (2020-03-14)"},{"location":"changelog/#features-improvements_5","text":"Introduce a super easy-to-extend plug-in system to PDM. #75","title":"Features &amp; Improvements"},{"location":"changelog/#improved-documentation","text":"Documentation on how to write a plugin. #75","title":"Improved Documentation"},{"location":"changelog/#bug-fixes_9","text":"Fix a typo in metadata parsing from plugins to entry_points","title":"Bug Fixes"},{"location":"changelog/#release-v042-2020-03-13","text":"","title":"Release v0.4.2 (2020-03-13)"},{"location":"changelog/#features-improvements_6","text":"Refactor the CLI part, switch from click to argparse , for better extensibility. #73 Allow users to configure to install packages into venv when it is activated. #74","title":"Features &amp; Improvements"},{"location":"changelog/#release-v041-2020-03-11","text":"","title":"Release v0.4.1 (2020-03-11)"},{"location":"changelog/#features-improvements_7","text":"Add a minimal dependency set for global project. #72","title":"Features &amp; Improvements"},{"location":"changelog/#release-v040-2020-03-10","text":"","title":"Release v0.4.0 (2020-03-10)"},{"location":"changelog/#features-improvements_8","text":"Global project support Add a new option -g/--global to manage global project. The default location is at ~/.pdm/global-project . Use the virtualenv interpreter when detected inside an activated venv. Add a new option -p/--project to select project root other than the default one. #30 Add a new command pdm config del to delete an existing config item. #71","title":"Features &amp; Improvements"},{"location":"changelog/#bug-fixes_10","text":"Fix a URL parsing issue that username will be dropped in the SSH URL. #68","title":"Bug Fixes"},{"location":"changelog/#improved-documentation_1","text":"Add docs for global project and selecting project path. #30","title":"Improved Documentation"},{"location":"changelog/#release-v032-2020-03-08","text":"","title":"Release v0.3.2 (2020-03-08)"},{"location":"changelog/#features-improvements_9","text":"Display all available Python interpreters if users don't give one in pdm init . #67","title":"Features &amp; Improvements"},{"location":"changelog/#bug-fixes_11","text":"Regard 4.0 as infinite upper bound when checking subsetting. #66","title":"Bug Fixes"},{"location":"changelog/#release-v031-2020-03-07","text":"","title":"Release v0.3.1 (2020-03-07)"},{"location":"changelog/#bug-fixes_12","text":"Fix a bug that ImpossiblePySpec 's hash clashes with normal one.","title":"Bug Fixes"},{"location":"changelog/#release-v030-2020-02-28","text":"","title":"Release v0.3.0 (2020-02-28)"},{"location":"changelog/#features-improvements_10","text":"Add a new command pdm config to inspect configurations. #26 Add a new command pdm cache clear to clean caches. #63","title":"Features &amp; Improvements"},{"location":"changelog/#bug-fixes_13","text":"Correctly show dependency graph when circular dependencies exist. #62","title":"Bug Fixes"},{"location":"changelog/#improved-documentation_2","text":"Write the initial documentation for PDM. #14","title":"Improved Documentation"},{"location":"changelog/#release-v026-2020-02-25","text":"","title":"Release v0.2.6 (2020-02-25)"},{"location":"changelog/#features-improvements_11","text":"Improve the user interface of selecting Python interpreter. #54","title":"Features &amp; Improvements"},{"location":"changelog/#bug-fixes_14","text":"Fix the wheel installer to correctly unparse the flags of console scripts. #56 Fix a bug that OS-dependent hashes are not saved. #57","title":"Bug Fixes"},{"location":"changelog/#release-v025-2020-02-22","text":"","title":"Release v0.2.5 (2020-02-22)"},{"location":"changelog/#features-improvements_12","text":"Allow specifying Python interpreter via --python option in pdm init . #49 Set python_requires when initializing and defaults to >={current_version} . #50","title":"Features &amp; Improvements"},{"location":"changelog/#bug-fixes_15","text":"Always consider wheels before tarballs; correctly merge markers from different parents. #47 Filter out incompatible wheels when installing. #48","title":"Bug Fixes"},{"location":"changelog/#release-v024-2020-02-21","text":"","title":"Release v0.2.4 (2020-02-21)"},{"location":"changelog/#bug-fixes_16","text":"Use the project local interpreter to build wheels. #43 Correctly merge Python specifiers when possible. #4","title":"Bug Fixes"},{"location":"changelog/#release-v023-2020-02-21","text":"","title":"Release v0.2.3 (2020-02-21)"},{"location":"changelog/#bug-fixes_17","text":"Fix a bug that editable build generates a malformed setup.py .","title":"Bug Fixes"},{"location":"changelog/#release-v022-2020-02-20","text":"","title":"Release v0.2.2 (2020-02-20)"},{"location":"changelog/#features-improvements_13","text":"Add a fancy greeting banner when user types pdm --help . #42","title":"Features &amp; Improvements"},{"location":"changelog/#bug-fixes_18","text":"Fix the RECORD file in built wheel. #41","title":"Bug Fixes"},{"location":"changelog/#dependencies_2","text":"Add dependency python-cfonts to display banner. #42","title":"Dependencies"},{"location":"changelog/#release-v021-2020-02-18","text":"","title":"Release v0.2.1 (2020-02-18)"},{"location":"changelog/#bug-fixes_19","text":"Fix a bug that short python_version markers can't be parsed correctly. #38 Make _editable_intall.py compatible with Py2.","title":"Bug Fixes"},{"location":"changelog/#release-v020-2020-02-14","text":"","title":"Release v0.2.0 (2020-02-14)"},{"location":"changelog/#features-improvements_14","text":"New option: pdm list --graph to show a dependency graph of the working set. #10 New option: pdm update --unconstrained to ignore the version constraint of given packages. #13 Improve the error message when project is not initialized before running comands. #19 Pinned candidates in lock file are reused when relocking during pdm install . #33 Use the pyenv interperter value if pyenv is installed. #36 Introduce a new command pdm info to show project environment information. #9","title":"Features &amp; Improvements"},{"location":"changelog/#bug-fixes_20","text":"Fix a bug that candidate hashes will be lost when reused. #11","title":"Bug Fixes"},{"location":"changelog/#dependencies_3","text":"Update pip to 20.0 , update pip_shims to 0.5.0 . #28","title":"Dependencies"},{"location":"changelog/#miscellany","text":"Add a script named setup_dev.py for the convenience to setup pdm for development. #29","title":"Miscellany"},{"location":"changelog/#release-v012-2020-02-09","text":"","title":"Release v0.1.2 (2020-02-09)"},{"location":"changelog/#features","text":"New command pdm use to switch python versions. #8 New option pdm list --graph to show a dependency graph. #10 Read metadata from lockfile when pinned candidate is reused.","title":"Features"},{"location":"changelog/#release-v011-2020-02-07","text":"","title":"Release v0.1.1 (2020-02-07)"},{"location":"changelog/#features_1","text":"Get version from the specified file. #6 Add column header to pdm list output.","title":"Features"},{"location":"changelog/#release-v010-2020-02-07","text":"","title":"Release v0.1.0 (2020-02-07)"},{"location":"changelog/#bugfixes","text":"Pass exit code to parent process in pdm run. Fix error handling for CLI. #19","title":"Bugfixes"},{"location":"changelog/#miscellany_1","text":"Refactor the installer mocking for tests.","title":"Miscellany"},{"location":"changelog/#release-v005-2020-01-22","text":"","title":"Release v0.0.5 (2020-01-22)"},{"location":"changelog/#improvements","text":"Ensure pypi index url is fetched in addition to the source settings. #3","title":"Improvements"},{"location":"changelog/#bugfixes_1","text":"Fix an issue that leading \"c\"s are mistakenly stripped. #5 Fix an error with PEP 517 building.","title":"Bugfixes"},{"location":"changelog/#release-v004-2020-01-22","text":"","title":"Release v0.0.4 (2020-01-22)"},{"location":"changelog/#improvements_1","text":"Fix editable installation, now editable scripts can also be executed from outside! Content hash is calculated based on dependencies and sources, not other metadata.","title":"Improvements"},{"location":"changelog/#bugfixes_2","text":"Fix an issue that editable distributions can not be removed.","title":"Bugfixes"},{"location":"changelog/#release-v003-2020-01-22","text":"","title":"Release v0.0.3 (2020-01-22)"},{"location":"changelog/#features_2","text":"Add pdm init to bootstrap a project.","title":"Features"},{"location":"changelog/#release-v002-2020-01-22","text":"","title":"Release v0.0.2 (2020-01-22)"},{"location":"changelog/#features_3","text":"A complete functioning PEP 517 build backend. pdm builld command.","title":"Features"},{"location":"changelog/#miscellany_2","text":"Add a Chinese REAME","title":"Miscellany"},{"location":"changelog/#features_4","text":"Add pdm init to bootstrap a project.","title":"Features"},{"location":"changelog/#release-v001-2020-01-20","text":"","title":"Release v0.0.1 (2020-01-20)"},{"location":"changelog/#features_5","text":"A dependency resolver that just works. A PEP 582 installer. PEP 440 version specifiers. PEP 508 environment markers. Running scripts with PEP 582 local packages. Console scripts are injected with local paths. A neet CLI. add, lock, list, update, remove commands. PEP 517 build backends. Continuous Integration.","title":"Features"},{"location":"contributing/","text":"Contributing to PDM # First off, thanks for taking the time to contribute! Contributions include but are not restricted to: Reporting bugs Contributing to code Writing tests Writing documents The following is a set of guidelines for contributing. A recommended flow of contributing to an Open Source project. # This guideline is for new beginners of OSS. If you are an experienced OSS developer, you can skip this section. First, fork this project to your own namespace using the fork button at the top right of the repository page. Clone the upstream repository to local: bash $ git clone https://github.com/frostming/pdm.git # Or if you prefer SSH clone: $ git clone git@github.com:frostming/pdm.git Add the fork as a new remote: bash $ git remote add fork https://github.com/yourname/pdm.git $ git fetch fork where fork is the remote name of the fork repository. ProTips: 1. Don't modify code on the master branch, the master branch should always keep in track with origin/master. To update master branch to date: bash $ git pull origin master # In rare cases that your local master branch diverges from the remote master: $ git fetch origin && git reset --hard master 2. Create a new branch based on the up-to-date master for new patches. 3. Create a Pull Request from that patch branch. Local development # To make sure the tests suites can run rightly, you need to install Git LFS , then $ git lfs install Then, you need to install base dependencies in a venv. Although PDM uses local package directory to install dependencies, venv is still needed to start up PDM at the first time: $ python setup_dev.py Now, all dependencies are installed into local __pypackages__ directory, which will be used for development after this point. The pdm executable located at __pypackages__/<VERSION>/bin can be run directly from outside, which is installed in editable mode, or you can use python -m pdm from inside the venv. Run tests # $ pdm run pytest tests The test suite is still simple and requires to be supplied, please help write more test cases. Code style # PDM uses pre-commit for linting, you need to install pre-commit first, then: $ pre-commit install $ pre-commit run --all-files PDM uses black coding style and isort for sorting import statements, if you are not following them, the CI will fail and your Pull Request will not be merged.","title":"Contributing"},{"location":"contributing/#contributing-to-pdm","text":"First off, thanks for taking the time to contribute! Contributions include but are not restricted to: Reporting bugs Contributing to code Writing tests Writing documents The following is a set of guidelines for contributing.","title":"Contributing to PDM"},{"location":"contributing/#a-recommended-flow-of-contributing-to-an-open-source-project","text":"This guideline is for new beginners of OSS. If you are an experienced OSS developer, you can skip this section. First, fork this project to your own namespace using the fork button at the top right of the repository page. Clone the upstream repository to local: bash $ git clone https://github.com/frostming/pdm.git # Or if you prefer SSH clone: $ git clone git@github.com:frostming/pdm.git Add the fork as a new remote: bash $ git remote add fork https://github.com/yourname/pdm.git $ git fetch fork where fork is the remote name of the fork repository. ProTips: 1. Don't modify code on the master branch, the master branch should always keep in track with origin/master. To update master branch to date: bash $ git pull origin master # In rare cases that your local master branch diverges from the remote master: $ git fetch origin && git reset --hard master 2. Create a new branch based on the up-to-date master for new patches. 3. Create a Pull Request from that patch branch.","title":"A recommended flow of contributing to an Open Source project."},{"location":"contributing/#local-development","text":"To make sure the tests suites can run rightly, you need to install Git LFS , then $ git lfs install Then, you need to install base dependencies in a venv. Although PDM uses local package directory to install dependencies, venv is still needed to start up PDM at the first time: $ python setup_dev.py Now, all dependencies are installed into local __pypackages__ directory, which will be used for development after this point. The pdm executable located at __pypackages__/<VERSION>/bin can be run directly from outside, which is installed in editable mode, or you can use python -m pdm from inside the venv.","title":"Local development"},{"location":"contributing/#run-tests","text":"$ pdm run pytest tests The test suite is still simple and requires to be supplied, please help write more test cases.","title":"Run tests"},{"location":"contributing/#code-style","text":"PDM uses pre-commit for linting, you need to install pre-commit first, then: $ pre-commit install $ pre-commit run --all-files PDM uses black coding style and isort for sorting import statements, if you are not following them, the CI will fail and your Pull Request will not be merged.","title":"Code style"},{"location":"dependency/","text":"Manage dependencies # PDM provides a bunch of handful commands to help manage your project and dependencies. The following examples are run on Ubuntu 18.04, a few changes must be done if you are using Windows. Initialize a project # $ mkdir pdm-test && cd pdm-test $ pdm init Answer several questions asked by PDM and a pyproject.toml will be created for you in the project root: [tool.pdm] name = \"pdm-test\" version = \"0.0.0\" description = \"\" author = \"Frost Ming <mianghong@gmail.com>\" license = \"MIT\" python_requires = \">=3.7\" [tool.pdm.dependencies] [tool.pdm.dev-dependencies] If pyproject.toml is already present, it will be updated with tool.pdm contents. For details of the meaning of each field in pyproject.toml , please refer to Project File . Add dependencies # $ pdm add requests $ pdm add -d pytest pdm add can be followed by one or several dependencies, and the dependency specification is described in PEP 508 . There are two groups of dependencies: packages will be added to [tool.pdm.dependencies] by default or [tool.pdm.dev-dependencies] if -d/--dev option is passed to the pdm add command. PDM also allows custom dependency groups by providing -s/--section <name> option, and the dependencies will apear in [tool.pdm.<name>-dependencies] in the project file, respectively. After that, dependencies and sub-dependencies will be resolved properly and installed for you, you can view pdm.lock to see the resolved result of all dependencies. Save version specifiers # If the package is given without a version specifier like pdm add requests . PDM provides three different behaviors of what version specifier is saved for the dependency, which is given by --save-<strategy> (Assume 2.21.0 is the latest version that can be found for the dependency): compatible : Save the compatible version specifier: >=2.21.0,<3.0.0 (default). exact : Save the exact version specifier: ==2.21.0 . wildcard : Don't constrain version and leave the specifier to be wildcard: * . Update existing dependencies # To update all dependencies in the lock file: $ pdm update To update the specified package(s): $ pdm update requests About update strategy # Similary, PDM also provides 2 different behaviors of updating dependencies and sub-dependencies\uff0c which is given by --update-<strategy> option: reuse : Keep all locked dependencies except for those given in the command line. eager : Try to lock a newer version of the packages in command line and their recursive sub-dependencies and keep other dependencies as they are. Remove existing dependencies # To remove existing dependencies from project file and the library directory: $ pdm remove requests Synchronize the project packages with lock file # There are two similar commands to do this job with a slight difference: pdm install will check the lock file and relock if it mismatch with project file, then install. pdm sync install dependencies in the lock file and will error out if it doesn't exist. Besides, pdm sync can also remove unneeded packages if --clean option is given. Show what packages are installed # Similar to pip list , you can list all packages installed in the packages directory: $ pdm list Or show a dependency graph by: $ pdm list --graph tempenv 0 .0.0 \u2514\u2500\u2500 click 7 .0 [ required: < 7 .0.0,> = 6 .7 ] black 19 .10b0 \u251c\u2500\u2500 appdirs 1 .4.3 [ required: Any ] \u251c\u2500\u2500 attrs 19 .3.0 [ required: > = 18 .1.0 ] \u251c\u2500\u2500 click 7 .0 [ required: > = 6 .5 ] \u251c\u2500\u2500 pathspec 0 .7.0 [ required: < 1 ,> = 0 .6 ] \u251c\u2500\u2500 regex 2020 .2.20 [ required: Any ] \u251c\u2500\u2500 toml 0 .10.0 [ required: > = 0 .9.4 ] \u2514\u2500\u2500 typed-ast 1 .4.1 [ required: > = 1 .4.0 ] bump2version 1 .0.0 Set PyPI index URL # You can specify a PyPI mirror URL by following commands: $ pdm config set pypi.url https://testpypi.org/simple By default, PDM will read the pip's configuration files to decide the PyPI URL, and fallback to https://pypi.org/simple if none is found. Add extra sources of packages # Sometimes your packages may exist on a private repository other than PyPI(and its mirrors). These sources should be preserved in pyproject.toml and shipped with the project in deployment. [[tool.pdm.source]] url = \"http://example.com/private/index\" verify_ssl = false # Don't verify SSL, it is required when you are using `HTTP` or the certificate is trusted. name = \"private\" Use the name name = \"pypi\" if you want to override the configurated PyPI index. Specify the index for one single dependency # You can specify which index should be consulted only for one single dependency: requests = { version = \"*\" , index = \"private\" }","title":"Manage dependencies"},{"location":"dependency/#manage-dependencies","text":"PDM provides a bunch of handful commands to help manage your project and dependencies. The following examples are run on Ubuntu 18.04, a few changes must be done if you are using Windows.","title":"Manage dependencies"},{"location":"dependency/#initialize-a-project","text":"$ mkdir pdm-test && cd pdm-test $ pdm init Answer several questions asked by PDM and a pyproject.toml will be created for you in the project root: [tool.pdm] name = \"pdm-test\" version = \"0.0.0\" description = \"\" author = \"Frost Ming <mianghong@gmail.com>\" license = \"MIT\" python_requires = \">=3.7\" [tool.pdm.dependencies] [tool.pdm.dev-dependencies] If pyproject.toml is already present, it will be updated with tool.pdm contents. For details of the meaning of each field in pyproject.toml , please refer to Project File .","title":"Initialize a project"},{"location":"dependency/#add-dependencies","text":"$ pdm add requests $ pdm add -d pytest pdm add can be followed by one or several dependencies, and the dependency specification is described in PEP 508 . There are two groups of dependencies: packages will be added to [tool.pdm.dependencies] by default or [tool.pdm.dev-dependencies] if -d/--dev option is passed to the pdm add command. PDM also allows custom dependency groups by providing -s/--section <name> option, and the dependencies will apear in [tool.pdm.<name>-dependencies] in the project file, respectively. After that, dependencies and sub-dependencies will be resolved properly and installed for you, you can view pdm.lock to see the resolved result of all dependencies.","title":"Add dependencies"},{"location":"dependency/#save-version-specifiers","text":"If the package is given without a version specifier like pdm add requests . PDM provides three different behaviors of what version specifier is saved for the dependency, which is given by --save-<strategy> (Assume 2.21.0 is the latest version that can be found for the dependency): compatible : Save the compatible version specifier: >=2.21.0,<3.0.0 (default). exact : Save the exact version specifier: ==2.21.0 . wildcard : Don't constrain version and leave the specifier to be wildcard: * .","title":"Save version specifiers"},{"location":"dependency/#update-existing-dependencies","text":"To update all dependencies in the lock file: $ pdm update To update the specified package(s): $ pdm update requests","title":"Update existing dependencies"},{"location":"dependency/#about-update-strategy","text":"Similary, PDM also provides 2 different behaviors of updating dependencies and sub-dependencies\uff0c which is given by --update-<strategy> option: reuse : Keep all locked dependencies except for those given in the command line. eager : Try to lock a newer version of the packages in command line and their recursive sub-dependencies and keep other dependencies as they are.","title":"About update strategy"},{"location":"dependency/#remove-existing-dependencies","text":"To remove existing dependencies from project file and the library directory: $ pdm remove requests","title":"Remove existing dependencies"},{"location":"dependency/#synchronize-the-project-packages-with-lock-file","text":"There are two similar commands to do this job with a slight difference: pdm install will check the lock file and relock if it mismatch with project file, then install. pdm sync install dependencies in the lock file and will error out if it doesn't exist. Besides, pdm sync can also remove unneeded packages if --clean option is given.","title":"Synchronize the project packages with lock file"},{"location":"dependency/#show-what-packages-are-installed","text":"Similar to pip list , you can list all packages installed in the packages directory: $ pdm list Or show a dependency graph by: $ pdm list --graph tempenv 0 .0.0 \u2514\u2500\u2500 click 7 .0 [ required: < 7 .0.0,> = 6 .7 ] black 19 .10b0 \u251c\u2500\u2500 appdirs 1 .4.3 [ required: Any ] \u251c\u2500\u2500 attrs 19 .3.0 [ required: > = 18 .1.0 ] \u251c\u2500\u2500 click 7 .0 [ required: > = 6 .5 ] \u251c\u2500\u2500 pathspec 0 .7.0 [ required: < 1 ,> = 0 .6 ] \u251c\u2500\u2500 regex 2020 .2.20 [ required: Any ] \u251c\u2500\u2500 toml 0 .10.0 [ required: > = 0 .9.4 ] \u2514\u2500\u2500 typed-ast 1 .4.1 [ required: > = 1 .4.0 ] bump2version 1 .0.0","title":"Show what packages are installed"},{"location":"dependency/#set-pypi-index-url","text":"You can specify a PyPI mirror URL by following commands: $ pdm config set pypi.url https://testpypi.org/simple By default, PDM will read the pip's configuration files to decide the PyPI URL, and fallback to https://pypi.org/simple if none is found.","title":"Set PyPI index URL"},{"location":"dependency/#add-extra-sources-of-packages","text":"Sometimes your packages may exist on a private repository other than PyPI(and its mirrors). These sources should be preserved in pyproject.toml and shipped with the project in deployment. [[tool.pdm.source]] url = \"http://example.com/private/index\" verify_ssl = false # Don't verify SSL, it is required when you are using `HTTP` or the certificate is trusted. name = \"private\" Use the name name = \"pypi\" if you want to override the configurated PyPI index.","title":"Add extra sources of packages"},{"location":"dependency/#specify-the-index-for-one-single-dependency","text":"You can specify which index should be consulted only for one single dependency: requests = { version = \"*\" , index = \"private\" }","title":"Specify the index for one single dependency"},{"location":"plugin/","text":"Write a plugin # PDM is aiming at being a community driven package manager. It is shipped with a full-featured plug-in system, with which you can: Develop a new command for PDM Add additional options to existing PDM commands Change PDM's behavior by reading additional config items Control the process of dependency resolution or installation What should a plugin do # The core PDM project focuses on dependency management and package publishment. Other functionalities you wish to integrate with PDM are preferred to lie in their own plugins and released as standalone PyPI projects. In case the plugin is considered a good suplement of the core project it may have a chance to be absorbed into PDM. Write your own plugin # In the following sections, I will show an example of adding a new command hello which reads hello.name config. Write the command # The PDM's CLI module is designed in a way that user can easily \"inherit and modify\". To write a new command: from pdm.cli.commands.base import BaseCommand class HelloCommand ( BaseCommand ): \"\"\"Say hello to the specified person. If none is given, will read from \"hello.name\" config. \"\"\" def add_arguments ( self , parser ): parser . add_argument ( \"-n\" , \"--name\" , help = \"the person's name to whom you greet\" ) def handle ( self , project , options ): if not options . name : name = project . config [ \"hello.name\" ] else : name = options . name print ( f \"Hello, { name } \" ) First create a new HelloCommand class inherting from pdm.cli.commands.base.BaseCommand , it has two major functions: add_arguments() to manipulate the argument parser passed as the only argument, where you can add additional command line arguments to it handle() to do something when the subcommand is matched, you can do nothing by writing a single pass statement. It accepts two arguments: an pdm.project.Project object as the first one and the parsed argparse.Namespace object as the second. The document string will serve as the command help text, which will be show in pdm --help . Besides, PDM's subcommand has two default options: -v/--verbose to change the verbosity level and -g/--global to enable global project. If you don't want these default options, override the arguments class attribute to a list of pdm.cli.options.Option objects. Assign it to an empty list to have no default options: class HelloCommand ( BaseCommand ): arguments = [] Note The default options are loaded first, then add_arguments() is called. Register the command to the core object # Write a function somewhere in your plugin project. There is no limit on what the name of the function is. The function should accept only one argument -- the PDM core object: def hello_plugin ( core ): core . register_command ( HelloCommand , \"hello\" ) Call core.register_command() to register the command, the second argument as the name of the subcommand is optional. PDM will look for the HelloCommand 's name attribute if the name is not passed. Add a new config item # Remember in the first code snippet, hello.name config key is consulted for the name if not passed via the command line. class HelloCommand ( BaseCommand ): \"\"\"Say hello to the specified person. If none is given, will read from \"hello.name\" config. \"\"\" def add_arguments ( self , parser ): parser . add_argument ( \"-n\" , \"--name\" , help = \"the person's name to whom you greet\" ) def handle ( self , project , options ): if not options . name : name = project . config [ \"hello.name\" ] else : name = options . name print ( f \"Hello, { name } \" ) Till now, if you query the config value by pdm config get hello.name , an error will pop up saying it is not a valid config key. You need to register the config item, too: from pdm.project.config import ConfigItem def hello_plugin ( core ): core . register_command ( HelloCommand , \"hello\" ) core . add_config ( \"hello.name\" , ConfigItem ( \"The person's name\" , \"John\" )) where ConfigItem class takes 4 parameters, in the following order: description : a description of the config item default : default value of the config item global_only : whether the config is allowed to set in home config only env_var : the name of environment variable which will be read as the config value Other plugin points # Besides commands and configurations, PDM provides some other plugin abilities which are not covered in the above example: core.project_class : change the class of project object core.repository_class : change the class of repository object, which controls how to look for candidates and metadata of a package core.resolver_class : change the resolver class, to control the resolution process core.synchronizer_class : change the synchronizer_class, to control the installation process core.parser : add arguments to the root argument parser Publish your plugin # Now you have defined your plugin already, let's distribute it to PyPI. PDM's plugins are discovered by entry point types. Create an pdm.plugin entry point and point to your plugin callable(yeah, it don't need to be a function, any callable object can work): PDM : # pyproject.toml [tool.pdm.entry_points.\"pdm.plugin\"] hello = \"my_plugin:hello_plugin\" Note that pdm.plugin is wrapped with double quotes to be regarded as a single key. setuptools : # setup.py setup ( ... entry_points = { \"pdm.plugin\" : [ \"hello = my_plugin:hello_plugin\" ]} ... )","title":"Write a plugin"},{"location":"plugin/#write-a-plugin","text":"PDM is aiming at being a community driven package manager. It is shipped with a full-featured plug-in system, with which you can: Develop a new command for PDM Add additional options to existing PDM commands Change PDM's behavior by reading additional config items Control the process of dependency resolution or installation","title":"Write a plugin"},{"location":"plugin/#what-should-a-plugin-do","text":"The core PDM project focuses on dependency management and package publishment. Other functionalities you wish to integrate with PDM are preferred to lie in their own plugins and released as standalone PyPI projects. In case the plugin is considered a good suplement of the core project it may have a chance to be absorbed into PDM.","title":"What should a plugin do"},{"location":"plugin/#write-your-own-plugin","text":"In the following sections, I will show an example of adding a new command hello which reads hello.name config.","title":"Write your own plugin"},{"location":"plugin/#write-the-command","text":"The PDM's CLI module is designed in a way that user can easily \"inherit and modify\". To write a new command: from pdm.cli.commands.base import BaseCommand class HelloCommand ( BaseCommand ): \"\"\"Say hello to the specified person. If none is given, will read from \"hello.name\" config. \"\"\" def add_arguments ( self , parser ): parser . add_argument ( \"-n\" , \"--name\" , help = \"the person's name to whom you greet\" ) def handle ( self , project , options ): if not options . name : name = project . config [ \"hello.name\" ] else : name = options . name print ( f \"Hello, { name } \" ) First create a new HelloCommand class inherting from pdm.cli.commands.base.BaseCommand , it has two major functions: add_arguments() to manipulate the argument parser passed as the only argument, where you can add additional command line arguments to it handle() to do something when the subcommand is matched, you can do nothing by writing a single pass statement. It accepts two arguments: an pdm.project.Project object as the first one and the parsed argparse.Namespace object as the second. The document string will serve as the command help text, which will be show in pdm --help . Besides, PDM's subcommand has two default options: -v/--verbose to change the verbosity level and -g/--global to enable global project. If you don't want these default options, override the arguments class attribute to a list of pdm.cli.options.Option objects. Assign it to an empty list to have no default options: class HelloCommand ( BaseCommand ): arguments = [] Note The default options are loaded first, then add_arguments() is called.","title":"Write the command"},{"location":"plugin/#register-the-command-to-the-core-object","text":"Write a function somewhere in your plugin project. There is no limit on what the name of the function is. The function should accept only one argument -- the PDM core object: def hello_plugin ( core ): core . register_command ( HelloCommand , \"hello\" ) Call core.register_command() to register the command, the second argument as the name of the subcommand is optional. PDM will look for the HelloCommand 's name attribute if the name is not passed.","title":"Register the command to the core object"},{"location":"plugin/#add-a-new-config-item","text":"Remember in the first code snippet, hello.name config key is consulted for the name if not passed via the command line. class HelloCommand ( BaseCommand ): \"\"\"Say hello to the specified person. If none is given, will read from \"hello.name\" config. \"\"\" def add_arguments ( self , parser ): parser . add_argument ( \"-n\" , \"--name\" , help = \"the person's name to whom you greet\" ) def handle ( self , project , options ): if not options . name : name = project . config [ \"hello.name\" ] else : name = options . name print ( f \"Hello, { name } \" ) Till now, if you query the config value by pdm config get hello.name , an error will pop up saying it is not a valid config key. You need to register the config item, too: from pdm.project.config import ConfigItem def hello_plugin ( core ): core . register_command ( HelloCommand , \"hello\" ) core . add_config ( \"hello.name\" , ConfigItem ( \"The person's name\" , \"John\" )) where ConfigItem class takes 4 parameters, in the following order: description : a description of the config item default : default value of the config item global_only : whether the config is allowed to set in home config only env_var : the name of environment variable which will be read as the config value","title":"Add a new config item"},{"location":"plugin/#other-plugin-points","text":"Besides commands and configurations, PDM provides some other plugin abilities which are not covered in the above example: core.project_class : change the class of project object core.repository_class : change the class of repository object, which controls how to look for candidates and metadata of a package core.resolver_class : change the resolver class, to control the resolution process core.synchronizer_class : change the synchronizer_class, to control the installation process core.parser : add arguments to the root argument parser","title":"Other plugin points"},{"location":"plugin/#publish-your-plugin","text":"Now you have defined your plugin already, let's distribute it to PyPI. PDM's plugins are discovered by entry point types. Create an pdm.plugin entry point and point to your plugin callable(yeah, it don't need to be a function, any callable object can work): PDM : # pyproject.toml [tool.pdm.entry_points.\"pdm.plugin\"] hello = \"my_plugin:hello_plugin\" Note that pdm.plugin is wrapped with double quotes to be regarded as a single key. setuptools : # setup.py setup ( ... entry_points = { \"pdm.plugin\" : [ \"hello = my_plugin:hello_plugin\" ]} ... )","title":"Publish your plugin"},{"location":"project/","text":"Manage project # PDM can act as a PEP 517 build backend, to enable that, write the following lines in your pyproject.toml . If you used pdm init to create it for you, it should be done already. [build-system] requires = [\"pdm\"] build-backend = \"pdm.builders.api\" pip will read the backend settings to install or build a package. About editable installation As described, PEP 517 doesn't provide a way to specify how to install a package in editable mode. So you can't install a PEP 517 package by pip install -e <path_or_url> . But PDM can install a \"PDM package\" in editable mode. Choose a Python interpreter # If you have used pdm init , you must have already seen how PDM detects and selects the Python interpreter. After initialized, you can also change the settings by pdm use <python_version_or_path> . The argument can be either a version specifier of any length, or a relative or absolute path to the python interpreter, but remember the Python interpreter must be compatible with python_requires constraint in the project file. How python_requires controls the project # PDM respects the value of python_requires in the way that it tries to pick package candidates that can work on all python versions that python_requires contains. For example if python_requires is >=2.7 , PDM will try to find the latest version of foo , whose python_requires version range is a superset of >=2.7 . So, make sure you write python_requires properly if you don't want any outdated packages to be locked. Build distribution artifacts # $ pdm build - Building sdist... - Built pdm-test-0.0.0.tar.gz - Building wheel... - Built pdm_test-0.0.0-py3-none-any.whl The artifacts can then be uploaded to PyPI by twine . Show the current Python environment # $ pdm info Python Interpreter: D:/Programs/Python/Python38/python.exe ( 3 .8.0 ) Project Root: D:/Workspace/pdm [ 10 :42 ] $ pdm info --env { \"implementation_name\" : \"cpython\" , \"implementation_version\" : \"3.8.0\" , \"os_name\" : \"nt\" , \"platform_machine\" : \"AMD64\" , \"platform_release\" : \"10\" , \"platform_system\" : \"Windows\" , \"platform_version\" : \"10.0.18362\" , \"python_full_version\" : \"3.8.0\" , \"platform_python_implementaiton\" : \"CPython\" , \"python_version\" : \"3.8\" , \"sys_platform\" : \"win32\" } Configrate the project # Show the configurations: $ pdm config Get one single configuration: $ pdm config get pypi.url Change a configuration value and store in home configuration: $ pdm config set pypi.url \"https://testpypi.org/simple\" Change a configuration value and store in .pdm.toml : $ pdm config set --local pypi.url \"https://testpypi.org/simple\" The configuration files are searched in the following order: <PROJECT_ROOT>/.pdm.toml - The project configuration ~/.pdm/config.toml - The home configuration If -g/--global option is used, ~/.pdm/global-project/.pdm.toml will replace the first item. Manage global project # Sometimes users may want to keep track of the dependencies of global Python interpreter. It is easy to do it with PDM, via -g/--global option which is supported by most subcommands. If the option is passed, ~/.pdm/global-project will be used as the project directory, which is almost the same as normal project except that pyproject.toml will be created automatically for you and it doesn't support build features. The idea is taken from Haskell's stack . However, unlike stack , by default, PDM won't use global project automatically if a local project is not found. Users should pass -g/--global explicitly to activate it, since it is not very pleasing if packages go to a wrong place. To change this behavior, simply change the config auto_global to true . If you want global project to track another project file other than ~/.pdm/global-project , you can provide the project path following -g/--global . NOTE Be careful with remove and sync --clean commands when global project is used. Because it may remove packages installed in your system Python. Working with a virtualenv # Although PDM enforces PEP 582 by default, it also allows users to install packages into the virtualenv. It is controlled by the configuration item use_venv . When it is set to True PDM will use the virtualenv if: an virtualenv is already activated. any of venv , .venv , env is an valid virtualenv folder. Import project metadata from existing project files # If you are already other package manager tools like Pipenv or Poetry, it is easy to migrate to PDM. PDM provides import command so that you don't have to initialize the project manually, it now supports: Pipenv's Pipfile Poetry's section in pyproject.toml Flit's section in pyproject.toml requirements.txt format used by Pip Also, when you are executing pdm init or pdm install , PDM can auto-detect possible files to import if your PDM project has not been initialized yet. Configurations # Config Item Description Default Value Available in Project Env var cache_dir The root directory of cached files The default cache location on OS No auto_global Use global package implicity if no local project is found False No PDM_AUTO_GLOBAL use_venv Install packages into the activated venv site packages instead of PEP 582 False Yes PDM_USE_VENV parallel_install Whether to perform installation and uninstallation in parallel True Yes PDM_PARALLEL_INSTALL python.path The Python interpreter path Yes PDM_PYTHON_PATH python.use_pyenv Use the pyenv interpreter True Yes pypi.url The URL of PyPI mirror Read index-url in pip.conf , or https://pypi.org/simple if not found Yes PDM_PYPI_URL pypi.verify_ssl Verify SSL certificate when query PyPI Read trusted-hosts in pip.conf , defaults to True Yes pypi.json_api Consult PyPI's JSON API for package metadata False Yes PDM_PYPI_JSON_API If the env var is set, the value will take precendence over what is saved in the config file.","title":"Manage project"},{"location":"project/#manage-project","text":"PDM can act as a PEP 517 build backend, to enable that, write the following lines in your pyproject.toml . If you used pdm init to create it for you, it should be done already. [build-system] requires = [\"pdm\"] build-backend = \"pdm.builders.api\" pip will read the backend settings to install or build a package. About editable installation As described, PEP 517 doesn't provide a way to specify how to install a package in editable mode. So you can't install a PEP 517 package by pip install -e <path_or_url> . But PDM can install a \"PDM package\" in editable mode.","title":"Manage project"},{"location":"project/#choose-a-python-interpreter","text":"If you have used pdm init , you must have already seen how PDM detects and selects the Python interpreter. After initialized, you can also change the settings by pdm use <python_version_or_path> . The argument can be either a version specifier of any length, or a relative or absolute path to the python interpreter, but remember the Python interpreter must be compatible with python_requires constraint in the project file.","title":"Choose a Python interpreter"},{"location":"project/#how-python_requires-controls-the-project","text":"PDM respects the value of python_requires in the way that it tries to pick package candidates that can work on all python versions that python_requires contains. For example if python_requires is >=2.7 , PDM will try to find the latest version of foo , whose python_requires version range is a superset of >=2.7 . So, make sure you write python_requires properly if you don't want any outdated packages to be locked.","title":"How python_requires controls the project"},{"location":"project/#build-distribution-artifacts","text":"$ pdm build - Building sdist... - Built pdm-test-0.0.0.tar.gz - Building wheel... - Built pdm_test-0.0.0-py3-none-any.whl The artifacts can then be uploaded to PyPI by twine .","title":"Build distribution artifacts"},{"location":"project/#show-the-current-python-environment","text":"$ pdm info Python Interpreter: D:/Programs/Python/Python38/python.exe ( 3 .8.0 ) Project Root: D:/Workspace/pdm [ 10 :42 ] $ pdm info --env { \"implementation_name\" : \"cpython\" , \"implementation_version\" : \"3.8.0\" , \"os_name\" : \"nt\" , \"platform_machine\" : \"AMD64\" , \"platform_release\" : \"10\" , \"platform_system\" : \"Windows\" , \"platform_version\" : \"10.0.18362\" , \"python_full_version\" : \"3.8.0\" , \"platform_python_implementaiton\" : \"CPython\" , \"python_version\" : \"3.8\" , \"sys_platform\" : \"win32\" }","title":"Show the current Python environment"},{"location":"project/#configrate-the-project","text":"Show the configurations: $ pdm config Get one single configuration: $ pdm config get pypi.url Change a configuration value and store in home configuration: $ pdm config set pypi.url \"https://testpypi.org/simple\" Change a configuration value and store in .pdm.toml : $ pdm config set --local pypi.url \"https://testpypi.org/simple\" The configuration files are searched in the following order: <PROJECT_ROOT>/.pdm.toml - The project configuration ~/.pdm/config.toml - The home configuration If -g/--global option is used, ~/.pdm/global-project/.pdm.toml will replace the first item.","title":"Configrate the project"},{"location":"project/#manage-global-project","text":"Sometimes users may want to keep track of the dependencies of global Python interpreter. It is easy to do it with PDM, via -g/--global option which is supported by most subcommands. If the option is passed, ~/.pdm/global-project will be used as the project directory, which is almost the same as normal project except that pyproject.toml will be created automatically for you and it doesn't support build features. The idea is taken from Haskell's stack . However, unlike stack , by default, PDM won't use global project automatically if a local project is not found. Users should pass -g/--global explicitly to activate it, since it is not very pleasing if packages go to a wrong place. To change this behavior, simply change the config auto_global to true . If you want global project to track another project file other than ~/.pdm/global-project , you can provide the project path following -g/--global . NOTE Be careful with remove and sync --clean commands when global project is used. Because it may remove packages installed in your system Python.","title":"Manage global project"},{"location":"project/#working-with-a-virtualenv","text":"Although PDM enforces PEP 582 by default, it also allows users to install packages into the virtualenv. It is controlled by the configuration item use_venv . When it is set to True PDM will use the virtualenv if: an virtualenv is already activated. any of venv , .venv , env is an valid virtualenv folder.","title":"Working with a virtualenv"},{"location":"project/#import-project-metadata-from-existing-project-files","text":"If you are already other package manager tools like Pipenv or Poetry, it is easy to migrate to PDM. PDM provides import command so that you don't have to initialize the project manually, it now supports: Pipenv's Pipfile Poetry's section in pyproject.toml Flit's section in pyproject.toml requirements.txt format used by Pip Also, when you are executing pdm init or pdm install , PDM can auto-detect possible files to import if your PDM project has not been initialized yet.","title":"Import project metadata from existing project files"},{"location":"project/#configurations","text":"Config Item Description Default Value Available in Project Env var cache_dir The root directory of cached files The default cache location on OS No auto_global Use global package implicity if no local project is found False No PDM_AUTO_GLOBAL use_venv Install packages into the activated venv site packages instead of PEP 582 False Yes PDM_USE_VENV parallel_install Whether to perform installation and uninstallation in parallel True Yes PDM_PARALLEL_INSTALL python.path The Python interpreter path Yes PDM_PYTHON_PATH python.use_pyenv Use the pyenv interpreter True Yes pypi.url The URL of PyPI mirror Read index-url in pip.conf , or https://pypi.org/simple if not found Yes PDM_PYPI_URL pypi.verify_ssl Verify SSL certificate when query PyPI Read trusted-hosts in pip.conf , defaults to True Yes pypi.json_api Consult PyPI's JSON API for package metadata False Yes PDM_PYPI_JSON_API If the env var is set, the value will take precendence over what is saved in the config file.","title":"Configurations"},{"location":"pyproject/","text":"Project file syntax # Project metadata # There are several differences from the metadata of setuptools : readme is the file name of README file and PDM can derive the content type automatically. author and maintainer is a combination of name and email address in the form of Name <email> . Package version # You can specify a file source for version field like: version = {from = \"pdm/__init__.py\"} , in this form, the version will be read from the __version__ variable in that file. Include and exclude pacakge files # The way of specifying include and exclude files are simple, they are given as a list of glob patterns: includes = [ \"**/*.json\" , \"mypackage/\" , ] excludes = [ \"mypackage/_temp/*\" ] If neither includes or excludes is given, PDM is also smart enough to include top level packages and all data files in them. Packages can also lie in src directory that PDM can find it. Dependency specification # Named requirement # requests = \">=2.20.0\" pytz = \"*\" \"*\" means there is no constraint of what version should be used. Requirement given by file URL # pdm = { url = \"https://github.com/frostming/marko/archive/0.2.6.zip\" } Requirement given by local path # requests = { path = \"/path/to/requests\" } In this case, the path should be a directory on local machine. If you want to install a local file , use url = \"file:///path/to/file instead. VCS requirement # requests = { git = \"https://github.com/frostming/marko.git\" , ref = \"master\" } PDM supports all VCS schemes that are supported by pip . Editable requirement # Both VCS requirement and local directory requirement can have an editable = true flag, meaning it should be installed in editable mode. Requirement with markers # requests = { version = \">=2.20.0\" , marker = \"os_name!='nt'\" } Console scripts # The following content: [tool.pdm.cli] mycli = \"mycli.__main__:main\" will be translated to setuptools style: entry_points = { 'console_scripts' : [ 'mycli=mycli.__main__:main' ] } Entry points # Other types of entry points are given by [tool.pdm.entry_points.<type>] section, with the same format of [tool.pdm.cli] format: [tool.pdm.entry_points.pytest11] myplugin = \"mypackage.plugin:pytest_plugin\" Build C extensions # Currently building C extensions still relies on setuptools . You should write a python script which contains a function named build and accepts the parameter dictionary of setup() as the only argument. Update the dictionary with your ext_modules settings in the function. Here is an example taken from MarkupSafe : # build.py from setuptools import Extension ext_modules = [ Extension ( \"markupsafe._speedups\" , [ \"src/markupsafe/_speedups.c\" ])] def build ( setup_kwargs ): setup_kwargs . update ( ext_modules = ext_modules ) Now, specify the build script path via build in the pyproject.toml : # pyproject.toml [tool.pdm] build = \"build.py\"","title":"Project file syntax"},{"location":"pyproject/#project-file-syntax","text":"","title":"Project file syntax"},{"location":"pyproject/#project-metadata","text":"There are several differences from the metadata of setuptools : readme is the file name of README file and PDM can derive the content type automatically. author and maintainer is a combination of name and email address in the form of Name <email> .","title":"Project metadata"},{"location":"pyproject/#package-version","text":"You can specify a file source for version field like: version = {from = \"pdm/__init__.py\"} , in this form, the version will be read from the __version__ variable in that file.","title":"Package version"},{"location":"pyproject/#include-and-exclude-pacakge-files","text":"The way of specifying include and exclude files are simple, they are given as a list of glob patterns: includes = [ \"**/*.json\" , \"mypackage/\" , ] excludes = [ \"mypackage/_temp/*\" ] If neither includes or excludes is given, PDM is also smart enough to include top level packages and all data files in them. Packages can also lie in src directory that PDM can find it.","title":"Include and exclude pacakge files"},{"location":"pyproject/#dependency-specification","text":"","title":"Dependency specification"},{"location":"pyproject/#named-requirement","text":"requests = \">=2.20.0\" pytz = \"*\" \"*\" means there is no constraint of what version should be used.","title":"Named requirement"},{"location":"pyproject/#requirement-given-by-file-url","text":"pdm = { url = \"https://github.com/frostming/marko/archive/0.2.6.zip\" }","title":"Requirement given by file URL"},{"location":"pyproject/#requirement-given-by-local-path","text":"requests = { path = \"/path/to/requests\" } In this case, the path should be a directory on local machine. If you want to install a local file , use url = \"file:///path/to/file instead.","title":"Requirement given by local path"},{"location":"pyproject/#vcs-requirement","text":"requests = { git = \"https://github.com/frostming/marko.git\" , ref = \"master\" } PDM supports all VCS schemes that are supported by pip .","title":"VCS requirement"},{"location":"pyproject/#editable-requirement","text":"Both VCS requirement and local directory requirement can have an editable = true flag, meaning it should be installed in editable mode.","title":"Editable requirement"},{"location":"pyproject/#requirement-with-markers","text":"requests = { version = \">=2.20.0\" , marker = \"os_name!='nt'\" }","title":"Requirement with markers"},{"location":"pyproject/#console-scripts","text":"The following content: [tool.pdm.cli] mycli = \"mycli.__main__:main\" will be translated to setuptools style: entry_points = { 'console_scripts' : [ 'mycli=mycli.__main__:main' ] }","title":"Console scripts"},{"location":"pyproject/#entry-points","text":"Other types of entry points are given by [tool.pdm.entry_points.<type>] section, with the same format of [tool.pdm.cli] format: [tool.pdm.entry_points.pytest11] myplugin = \"mypackage.plugin:pytest_plugin\"","title":"Entry points"},{"location":"pyproject/#build-c-extensions","text":"Currently building C extensions still relies on setuptools . You should write a python script which contains a function named build and accepts the parameter dictionary of setup() as the only argument. Update the dictionary with your ext_modules settings in the function. Here is an example taken from MarkupSafe : # build.py from setuptools import Extension ext_modules = [ Extension ( \"markupsafe._speedups\" , [ \"src/markupsafe/_speedups.c\" ])] def build ( setup_kwargs ): setup_kwargs . update ( ext_modules = ext_modules ) Now, specify the build script path via build in the pyproject.toml : # pyproject.toml [tool.pdm] build = \"build.py\"","title":"Build C extensions"}]}